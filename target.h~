#pragma once
#include "IObserver.h"
#include "pnt_sensor.h"
#include <iostream> 

class target :
	public IObserver
{
public:
	Distance  _d;
	Velocity _v;
	Position _uav_pos;
	Track _tgt_track;
	time_point<system_clock, milliseconds> _now;

	int _frequence;

public:
	target(Distance const& d, Velocity const& v, time_point<system_clock, milliseconds> const &now, int fq = 1) :_now(now), _frequence(fq) {
		setDistance(d);
		setVelocity(v);
	};

	~target() {};

	void setDistance(Distance const& d)
	{
		_d._dx = d._dx;
		_d._dy = d._dy;
		_d._dz = d._dz;
	};

	void setUAVLocation(Position const& p)
	{
		_uav_pos._x = p._x;
		_uav_pos._y = p._y;
		_uav_pos._z = p._z;
	};

	void setVelocity(Velocity const& v)
	{
		_v._dx = v._dx;
		_v._dy = v._dy;
		_v._dz = v._dz;
	};

	virtual void notified(pnt_sensor* ps)
	{
		calTargetLocation(ps->getVelocity(), ps->getTimePoint());
		
		static int cnt = 0; 
		int per_cycle = static_cast<int> (((1.0 / _frequence) / (sleep_msec / 1000)));
		if (per_cycle != 0 && 0 == ++cnt % per_cycle)  
			print_track();
	};


	void print_track()
	{
		std::cout << "				--- Target TRACK ---" << std::endl
			<< "					x=" << _tgt_track._pos._x << std::endl
			<< "					y=" << _tgt_track._pos._y << std::endl
			<< "					z=" << _tgt_track._pos._z << std::endl << std::endl;
	}

private:
	void calTargetLocation(Velocity const& v, time_point<system_clock, milliseconds> const & now)
	{
		auto  dt = now.time_since_epoch() - _now.time_since_epoch();
		double ddt = dt.count() / 1000.0;
		_tgt_track._pos._x = _uav_pos._x + v._dx * ddt;
		_tgt_track._pos._y = _uav_pos._y + v._dy * ddt;
		_tgt_track._pos._z = _uav_pos._z + v._dz * ddt;
		_tgt_track._v = v;
		_now = now;
	}
























};

